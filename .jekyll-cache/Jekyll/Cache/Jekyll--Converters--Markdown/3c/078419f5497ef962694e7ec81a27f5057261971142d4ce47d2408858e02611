I"Û9<p class="notice--warning">I‚Äôm not an authority on this - take my explanation with a grain of skepticism
and do your own research.</p>

<p>I‚Äôve been working on going over some of the fundamentals of computer science
recently since I don‚Äôt have a traditional computer science education. 
Pass-by-value recently came up, and I thought it would be a quick foray to
properly learn the difference between pass-by-value and pass-by-reference.
Surely something so fundamental must have clear answers, right?</p>

<p>And then it turned into a huge fucking rabbit hole, with lots of dissenting
views, and very confusing discussions. Just Google it, check out some of the
StackOverflow articles. There‚Äôs a lot of content, but it‚Äôs not very clear.
In the abstract, the concepts are simple. In the context of Python and Ruby,
it‚Äôs a confusing mess.</p>

<p>So that‚Äôs what this post is about - trying to clarify, the
differences between the two and what ‚Äúpass-reference-by-value‚Äù actually means.</p>

<h2 id="quick-naive-explanation">Quick, naive explanation</h2>

<p>The TL;DR version of pass-by-value vs pass-by-reference is simple - pass by
value means the value of a function parameter gets <em>copied</em> into the body of a
function, but it‚Äôs not the same object in memory as the original parameter. You
can‚Äôt mutate or change whatever you passed into the function, because your
function doesn‚Äôt actually know about the original ‚Äúthing‚Äù - it only has a copy
of the value of the ‚Äúthing.‚Äù</p>

<p>Pass-by-reference is the opposite. When you invoke a function with a parameter,
the function body is referring to the same object in memory as the original.
Any mutations of the object inside the function body will be persisted outside
of the function body.</p>

<p>We can see an example of pass-by-value with a little Ruby:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_string</span> <span class="o">=</span> <span class="s1">'foo'</span>
<span class="nb">puts</span> <span class="s2">"my_string is '</span><span class="si">#{</span><span class="n">my_string</span><span class="si">}</span><span class="s2">'"</span> <span class="c1"># my_string is 'foo'</span>

<span class="k">def</span> <span class="nf">mutate</span><span class="p">(</span><span class="n">some_string</span><span class="p">)</span>
    <span class="n">some_string</span> <span class="o">=</span> <span class="s1">'not foo'</span>
    <span class="nb">puts</span> <span class="s2">"string inside function is '</span><span class="si">#{</span><span class="n">some_string</span><span class="si">}</span><span class="s2">'"</span>
<span class="k">end</span>

<span class="n">mutate</span><span class="p">(</span><span class="n">my_string</span><span class="p">)</span> <span class="c1"># string inside function is 'not foo'</span>

<span class="nb">puts</span> <span class="s2">"my_string is still '</span><span class="si">#{</span><span class="n">my_string</span><span class="si">}</span><span class="s2">'"</span> <span class="c1"># my_string is still 'foo'</span>
</code></pre></div></div>

<p>You can do the same thing in Python, Java, or any other pass-by-value language
and get the same result. And it makes perfect sense - inside the function,
<code class="language-plaintext highlighter-rouge">some_string</code> simply has the <em>value</em> of <code class="language-plaintext highlighter-rouge">foo</code>, so if we assign it to something
else it doesn‚Äôt affect <code class="language-plaintext highlighter-rouge">my_string</code> elsewhere in the function.</p>

<h2 id="a-contradicting-example">A contradicting example</h2>

<p>Let‚Äôs do one more simple example in Ruby, to build confidence in our newfound
understanding.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_string</span> <span class="o">=</span> <span class="s1">'foo'</span>
<span class="nb">puts</span> <span class="s2">"my_string is '</span><span class="si">#{</span><span class="n">my_string</span><span class="si">}</span><span class="s2">'"</span> <span class="c1"># my_string is 'foo'</span>

<span class="k">def</span> <span class="nf">mutate</span><span class="p">(</span><span class="n">some_string</span><span class="p">)</span>
    <span class="n">some_string</span><span class="p">.</span><span class="nf">upcase!</span>
    <span class="nb">puts</span> <span class="s2">"string inside function is '</span><span class="si">#{</span><span class="n">some_string</span><span class="si">}</span><span class="s2">'"</span>
<span class="k">end</span>

<span class="n">mutate</span><span class="p">(</span><span class="n">my_string</span><span class="p">)</span> <span class="c1"># string inside function is 'FOO'</span>

<span class="nb">puts</span> <span class="s2">"my_string is now '</span><span class="si">#{</span><span class="n">my_string</span><span class="si">}</span><span class="s2">'"</span> <span class="c1"># my_string is now 'FOO'</span>
</code></pre></div></div>

<p>Confused? Yeah, me too. This confusion is what spurred my research. We know
Ruby uses pass-by-value, we just empirically demonstrated that as fact - so how
is it possible that we could mutate an object inside of a function and have
that change persist outside of the function?</p>

<p>For anyone who uses Ruby or Python, they might argue that it <em>behaves</em>
like pass-by-reference. Other people would explain the behavior by saying Ruby 
and Python are ‚Äúpass-reference-by-value‚Äù or ‚Äúpass-object-by-value‚Äù but what
exactly does that mean?</p>

<h2 id="more-layers-to-the-cake">More layers to the cake</h2>

<p>It turns out that there are really two layers to this behavior, and everything
makes a lot more sense once you are familiar with them.</p>

<p>A language can support pass-by-reference or pass-by-value semantics, or both.
For example, <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/passing-parameters">C# supports both</a>
On top of that, the <em>type</em> of parameters you pass into a function can be a
value type or a reference type, <strong>regardless</strong> of whether pass-by-value or
pass-by-reference semantics are used. This is what makes classifying languages
so confusing - a language that uses pass-by-value semantics and reference types
appears to behave like pass-by-reference.</p>

<p>Let‚Äôs go back to our Ruby examples. Ruby is always pass-by-value. However we
saw earlier that it behaved like a pass-by-reference language. That‚Äôs because
the <em>value</em> of the <code class="language-plaintext highlighter-rouge">my_string</code> parameter is a <em>reference</em> to an object in
memory. The value is still being copied when the function is invoked (hence
pass-by-value), but the value is a reference to the same object in memory.</p>

<p>Let‚Äôs do another quick example in Ruby to demonstrate this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_string</span> <span class="o">=</span> <span class="s1">'foo'</span>
<span class="nb">puts</span> <span class="s2">"my_string is '</span><span class="si">#{</span><span class="n">my_string</span><span class="si">}</span><span class="s2">'"</span> <span class="c1"># my_string is 'foo'</span>
<span class="nb">puts</span> <span class="n">my_string</span><span class="p">.</span><span class="nf">object_id</span> <span class="c1"># 60</span>

<span class="k">def</span> <span class="nf">mutate</span><span class="p">(</span><span class="n">some_string</span><span class="p">)</span>
    <span class="nb">puts</span> <span class="n">some_string</span><span class="p">.</span><span class="nf">object_id</span> <span class="c1"># 60</span>
    <span class="n">some_string</span><span class="p">.</span><span class="nf">upcase!</span>
    <span class="c1"># object_id will still be 60 - still referring to the same object in memory</span>
    <span class="nb">puts</span> <span class="n">some_string</span><span class="p">.</span><span class="nf">object_id</span> <span class="c1"># 60</span>
    <span class="nb">puts</span> <span class="s2">"string inside function is '</span><span class="si">#{</span><span class="n">some_string</span><span class="si">}</span><span class="s2">'"</span> <span class="c1"># string inside function is 'FOO'</span>

    <span class="c1"># assigning a value to `some_string` creates a new object in memory, and the value</span>
    <span class="c1"># is updated to reference that new object in memory. it did not change the original</span>
    <span class="c1"># object in memory. because of this, the ID will be different</span>
    <span class="n">some_string</span> <span class="o">=</span> <span class="s1">'not foo'</span>
    <span class="nb">puts</span> <span class="n">some_string</span><span class="p">.</span><span class="nf">object_id</span> <span class="c1"># 80</span>
<span class="k">end</span>

<span class="n">mutate</span><span class="p">(</span><span class="n">my_string</span><span class="p">)</span>

<span class="nb">puts</span> <span class="s2">"my_string is now '</span><span class="si">#{</span><span class="n">my_string</span><span class="si">}</span><span class="s2">'"</span> <span class="c1"># my_string is now 'FOO'</span>
</code></pre></div></div>

<p>For those who need visual help like me, here‚Äôs a series of diagrams explaining
the same concept. In each digram, the code will be on the left and a
model of the objects in memory will be on the right.</p>

<p>When we first initialize <code class="language-plaintext highlighter-rouge">my_string</code> with the value <code class="language-plaintext highlighter-rouge">'foo'</code>, a new object is
created in memory that holds the string <code class="language-plaintext highlighter-rouge">foo</code>.</p>

<p class="text-center"><img class="aligncenter size-large" src="https://www.alexdglover.com/assets/pass-reference-by-value-1.png" alt="Pass Reference by Value - Diagram 1" /></p>

<p>When we invoke the <code class="language-plaintext highlighter-rouge">mutate</code> method and pass in <code class="language-plaintext highlighter-rouge">my_string</code>, a <em>copy</em> of
<code class="language-plaintext highlighter-rouge">my_string</code> is made. That copy has the variable name <code class="language-plaintext highlighter-rouge">some_string</code>, and the
value of the variable is the <em>reference</em> to the object in memory (not the 
string <code class="language-plaintext highlighter-rouge">foo</code>). It‚Äôs a new variable inside of the function scope, but it refers
to the same object in memory.</p>

<p class="text-center"><img class="aligncenter size-large" src="https://www.alexdglover.com/assets/pass-reference-by-value-2.png" alt="Pass Reference by Value - Diagram 2" /></p>

<p>If we mutate the object inside the function body, it affects the object
both inside and outside of the function scope.</p>

<p class="text-center"><img class="aligncenter size-large" src="https://www.alexdglover.com/assets/pass-reference-by-value-3.png" alt="Pass Reference by Value - Diagram 3" /></p>

<p>Now here‚Äôs where the difference between pass-reference-by-value and true
pass-by-reference is made clear. If Ruby were pass-by-reference, we could
update <code class="language-plaintext highlighter-rouge">my_string</code> to refer to a new object in memory. But we can‚Äôt - we never
actually had <code class="language-plaintext highlighter-rouge">my_string</code> within the scope of our function, just a copy of that
variable that refers to the same object in memory. If we try to assign
<code class="language-plaintext highlighter-rouge">some_string</code> to a new object, it has no effect on <code class="language-plaintext highlighter-rouge">my_string</code> outside of the
function body. It just creates a new object in memory.</p>

<p class="text-center"><img class="aligncenter size-large" src="https://www.alexdglover.com/assets/pass-reference-by-value-4.png" alt="Pass Reference by Value - Diagram 4" /></p>

<h2 id="compared-to-languages-with-pointers">Compared to languages with pointers</h2>

<p>Rust, Golang, C, and C++ all support pointers. Some people will say that this
means you can write functions with pass-by-value or pass-by-reference
semantics. Don‚Äôt believe their lies - strictly speaking, these languages are
also pass-by-value.</p>

<p>In Ruby and Python, every variable is a reference to an object in memory. In
Rust/Golang/C++, both references and pointers are supported. However the
differences between <a href="https://www.geeksforgeeks.org/pointers-vs-references-cpp/">pointers and references</a>
is subtle, and don‚Äôt affect the examples we used in this post.
The ELI5 version is that references are like ‚Äúimplicit pointers‚Äù and don‚Äôt
require extra syntax to de-reference them. We could implement the same
exercises above in any of these languages, using references <em>or</em> pointers, and
the behavior would be the same.</p>

<p>So the only real difference is that these languages require us to be explicit
about pointers/references, whereas Ruby and Python use references implicitly.</p>

<h2 id="conclusion">Conclusion</h2>

<p>In short, pass-reference-by-value is just pass-by-value with implicit 
references. Unless you‚Äôre using C#, Perl, or some exotic language, you‚Äôre more
than likely using pass-by-value, either with explicit pointers/references
(Golang, Rust, C++) or implicit references (Python, Ruby).</p>

<p>I hope this helps demystify the nature of pass-reference-by-value for you and
spares you the StackOverflow rabbit hole. Here are some links for content I
reviewed to learn about this, in case you want to do your own research:</p>

<ul>
  <li><a href="https://robertheaton.com/2014/07/22/is-ruby-pass-by-reference-or-pass-by-value/">Is Ruby pass by reference or pass by value?</a></li>
  <li>my post is like the ELI5 version of this post. What I didn‚Äôt understand was
that <em>assignment</em> was the key difference in behavior</li>
  <li><a href="https://stackoverflow.com/questions/1872110/is-ruby-pass-by-reference-or-by-value">StackOverflow - Is Ruby pass by reference or by value?</a>
    <ul>
      <li><a href="https://stackoverflow.com/a/10974116">This answer</a> in particular made
  it more clear to me</li>
    </ul>
  </li>
  <li><a href="https://stackoverflow.com/questions/12438153/c-sharp-vs-python-argument-passing">C# vs Python argument passing</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Value_type_and_reference_type">Value type and reference type</a></li>
  <li><a href="https://launchschool.com/blog/references-and-mutability-in-ruby">Variable References and Mutability in Ruby</a></li>
</ul>
:ET